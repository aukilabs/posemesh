/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.1
 * source: task.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./domain_data";
import * as pb_1 from "google-protobuf";
export namespace task {
    export enum Code {
        OK = 200,
        Created = 201,
        Accepted = 202,
        BadRequest = 400
    }
    export enum Status {
        PENDING = 0,
        STARTED = 1,
        DONE = 2,
        FAILED = 3,
        WAITING_FOR_RESOURCE = 4,
        RETRY = 5,
        PROCESSING = 6
    }
    export class Any extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type_url: string;
            value: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.type_url = data.type_url;
                this.value = data.value;
            }
        }
        get type_url() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set type_url(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_type_url() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get value() {
            return pb_1.Message.getField(this, 2) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_value() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            type_url?: string;
            value?: Uint8Array;
        }): Any {
            const message = new Any({
                type_url: data.type_url,
                value: data.value
            });
            return message;
        }
        toObject() {
            const data: {
                type_url?: string;
                value?: Uint8Array;
            } = {};
            if (this.type_url != null) {
                data.type_url = this.type_url;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_type_url && this.type_url.length)
                writer.writeString(1, this.type_url);
            if (this.has_value && this.value.length)
                writer.writeBytes(2, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Any {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Any();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type_url = reader.readString();
                        break;
                    case 2:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Any {
            return Any.deserialize(bytes);
        }
    }
    export class JobRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name: string;
            tasks: TaskRequest[];
            nonce: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.name = data.name;
                this.tasks = data.tasks;
                this.nonce = data.nonce;
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_name() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get tasks() {
            return pb_1.Message.getRepeatedWrapperField(this, TaskRequest, 2) as TaskRequest[];
        }
        set tasks(value: TaskRequest[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get nonce() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set nonce(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_nonce() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            name?: string;
            tasks?: ReturnType<typeof TaskRequest.prototype.toObject>[];
            nonce?: string;
        }): JobRequest {
            const message = new JobRequest({
                name: data.name,
                tasks: data.tasks.map(item => TaskRequest.fromObject(item)),
                nonce: data.nonce
            });
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                tasks?: ReturnType<typeof TaskRequest.prototype.toObject>[];
                nonce?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.tasks != null) {
                data.tasks = this.tasks.map((item: TaskRequest) => item.toObject());
            }
            if (this.nonce != null) {
                data.nonce = this.nonce;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_name && this.name.length)
                writer.writeString(1, this.name);
            if (this.tasks.length)
                writer.writeRepeatedMessage(2, this.tasks, (item: TaskRequest) => item.serialize(writer));
            if (this.has_nonce && this.nonce.length)
                writer.writeString(3, this.nonce);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JobRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JobRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.tasks, () => pb_1.Message.addToRepeatedWrapperField(message, 2, TaskRequest.deserialize(reader), TaskRequest));
                        break;
                    case 3:
                        message.nonce = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): JobRequest {
            return JobRequest.deserialize(bytes);
        }
    }
    export class Job extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id: string;
            name: string;
            tasks: Task[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.id = data.id;
                this.name = data.name;
                this.tasks = data.tasks;
            }
        }
        get id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_id() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_name() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get tasks() {
            return pb_1.Message.getRepeatedWrapperField(this, Task, 3) as Task[];
        }
        set tasks(value: Task[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            id?: string;
            name?: string;
            tasks?: ReturnType<typeof Task.prototype.toObject>[];
        }): Job {
            const message = new Job({
                id: data.id,
                name: data.name,
                tasks: data.tasks.map(item => Task.fromObject(item))
            });
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                name?: string;
                tasks?: ReturnType<typeof Task.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.tasks != null) {
                data.tasks = this.tasks.map((item: Task) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_id && this.id.length)
                writer.writeString(1, this.id);
            if (this.has_name && this.name.length)
                writer.writeString(2, this.name);
            if (this.tasks.length)
                writer.writeRepeatedMessage(3, this.tasks, (item: Task) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Job {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Job();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.tasks, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Task.deserialize(reader), Task));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Job {
            return Job.deserialize(bytes);
        }
    }
    export class SubmitJobResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            code: Code;
            job_id: string;
            err_msg: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.code = data.code;
                this.job_id = data.job_id;
                this.err_msg = data.err_msg;
            }
        }
        get code() {
            return pb_1.Message.getField(this, 1) as Code;
        }
        set code(value: Code) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_code() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get job_id() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set job_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_job_id() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get err_msg() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set err_msg(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_err_msg() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            code?: Code;
            job_id?: string;
            err_msg?: string;
        }): SubmitJobResponse {
            const message = new SubmitJobResponse({
                code: data.code,
                job_id: data.job_id,
                err_msg: data.err_msg
            });
            return message;
        }
        toObject() {
            const data: {
                code?: Code;
                job_id?: string;
                err_msg?: string;
            } = {};
            if (this.code != null) {
                data.code = this.code;
            }
            if (this.job_id != null) {
                data.job_id = this.job_id;
            }
            if (this.err_msg != null) {
                data.err_msg = this.err_msg;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_code)
                writer.writeEnum(1, this.code);
            if (this.has_job_id && this.job_id.length)
                writer.writeString(2, this.job_id);
            if (this.has_err_msg && this.err_msg.length)
                writer.writeString(3, this.err_msg);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubmitJobResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SubmitJobResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.code = reader.readEnum();
                        break;
                    case 2:
                        message.job_id = reader.readString();
                        break;
                    case 3:
                        message.err_msg = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SubmitJobResponse {
            return SubmitJobResponse.deserialize(bytes);
        }
    }
    export class TaskRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name: string;
            capability_filters: CapabilityFilters;
            max_budget?: number;
            timeout: string;
            needs: string[];
            resource_recruitment: ResourceRecruitment;
            sender: string;
            receiver?: string;
            data?: Any;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.name = data.name;
                this.capability_filters = data.capability_filters;
                if ("max_budget" in data && data.max_budget != undefined) {
                    this.max_budget = data.max_budget;
                }
                this.timeout = data.timeout;
                this.needs = data.needs;
                this.resource_recruitment = data.resource_recruitment;
                this.sender = data.sender;
                if ("receiver" in data && data.receiver != undefined) {
                    this.receiver = data.receiver;
                }
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_name() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get capability_filters() {
            return pb_1.Message.getWrapperField(this, CapabilityFilters, 2) as CapabilityFilters;
        }
        set capability_filters(value: CapabilityFilters) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_capability_filters() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get max_budget() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set max_budget(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_max_budget() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get timeout() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set timeout(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_timeout() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get needs() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as string[];
        }
        set needs(value: string[]) {
            pb_1.Message.setField(this, 5, value);
        }
        get resource_recruitment() {
            return pb_1.Message.getWrapperField(this, ResourceRecruitment, 6) as ResourceRecruitment;
        }
        set resource_recruitment(value: ResourceRecruitment) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get has_resource_recruitment() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get sender() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_sender() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get receiver() {
            return pb_1.Message.getFieldWithDefault(this, 8, "") as string;
        }
        set receiver(value: string) {
            pb_1.Message.setField(this, 8, value);
        }
        get has_receiver() {
            return pb_1.Message.getField(this, 8) != null;
        }
        get data() {
            return pb_1.Message.getWrapperField(this, Any, 9) as Any;
        }
        set data(value: Any) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get has_data() {
            return pb_1.Message.getField(this, 9) != null;
        }
        static fromObject(data: {
            name?: string;
            capability_filters?: ReturnType<typeof CapabilityFilters.prototype.toObject>;
            max_budget?: number;
            timeout?: string;
            needs: string[];
            resource_recruitment?: ReturnType<typeof ResourceRecruitment.prototype.toObject>;
            sender?: string;
            receiver?: string;
            data?: ReturnType<typeof Any.prototype.toObject>;
        }): TaskRequest {
            const message = new TaskRequest({
                name: data.name,
                capability_filters: CapabilityFilters.fromObject(data.capability_filters),
                timeout: data.timeout,
                needs: data.needs,
                resource_recruitment: ResourceRecruitment.fromObject(data.resource_recruitment),
                sender: data.sender
            });
            if (data.max_budget != null) {
                message.max_budget = data.max_budget;
            }
            if (data.receiver != null) {
                message.receiver = data.receiver;
            }
            if (data.data != null) {
                message.data = Any.fromObject(data.data);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                capability_filters?: ReturnType<typeof CapabilityFilters.prototype.toObject>;
                max_budget?: number;
                timeout?: string;
                needs: string[];
                resource_recruitment?: ReturnType<typeof ResourceRecruitment.prototype.toObject>;
                sender?: string;
                receiver?: string;
                data?: ReturnType<typeof Any.prototype.toObject>;
            } = {
                needs: this.needs
            };
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.capability_filters != null) {
                data.capability_filters = this.capability_filters.toObject();
            }
            if (this.max_budget != null) {
                data.max_budget = this.max_budget;
            }
            if (this.timeout != null) {
                data.timeout = this.timeout;
            }
            if (this.resource_recruitment != null) {
                data.resource_recruitment = this.resource_recruitment.toObject();
            }
            if (this.sender != null) {
                data.sender = this.sender;
            }
            if (this.receiver != null) {
                data.receiver = this.receiver;
            }
            if (this.data != null) {
                data.data = this.data.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_name && this.name.length)
                writer.writeString(1, this.name);
            if (this.has_capability_filters)
                writer.writeMessage(2, this.capability_filters, () => this.capability_filters.serialize(writer));
            if (this.has_max_budget)
                writer.writeUint64(3, this.max_budget);
            if (this.has_timeout && this.timeout.length)
                writer.writeString(4, this.timeout);
            if (this.needs.length)
                writer.writeRepeatedString(5, this.needs);
            if (this.has_resource_recruitment)
                writer.writeMessage(6, this.resource_recruitment, () => this.resource_recruitment.serialize(writer));
            if (this.has_sender && this.sender.length)
                writer.writeString(7, this.sender);
            if (this.has_receiver && this.receiver.length)
                writer.writeString(8, this.receiver);
            if (this.has_data)
                writer.writeMessage(9, this.data, () => this.data.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TaskRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TaskRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.capability_filters, () => message.capability_filters = CapabilityFilters.deserialize(reader));
                        break;
                    case 3:
                        message.max_budget = reader.readUint64();
                        break;
                    case 4:
                        message.timeout = reader.readString();
                        break;
                    case 5:
                        pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                        break;
                    case 6:
                        reader.readMessage(message.resource_recruitment, () => message.resource_recruitment = ResourceRecruitment.deserialize(reader));
                        break;
                    case 7:
                        message.sender = reader.readString();
                        break;
                    case 8:
                        message.receiver = reader.readString();
                        break;
                    case 9:
                        reader.readMessage(message.data, () => message.data = Any.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TaskRequest {
            return TaskRequest.deserialize(bytes);
        }
    }
    export class CapabilityFilters extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            endpoint: string;
            min_gpu?: number;
            min_cpu?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.endpoint = data.endpoint;
                if ("min_gpu" in data && data.min_gpu != undefined) {
                    this.min_gpu = data.min_gpu;
                }
                if ("min_cpu" in data && data.min_cpu != undefined) {
                    this.min_cpu = data.min_cpu;
                }
            }
        }
        get endpoint() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set endpoint(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_endpoint() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get min_gpu() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set min_gpu(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_min_gpu() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get min_cpu() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set min_cpu(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_min_cpu() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            endpoint?: string;
            min_gpu?: number;
            min_cpu?: number;
        }): CapabilityFilters {
            const message = new CapabilityFilters({
                endpoint: data.endpoint
            });
            if (data.min_gpu != null) {
                message.min_gpu = data.min_gpu;
            }
            if (data.min_cpu != null) {
                message.min_cpu = data.min_cpu;
            }
            return message;
        }
        toObject() {
            const data: {
                endpoint?: string;
                min_gpu?: number;
                min_cpu?: number;
            } = {};
            if (this.endpoint != null) {
                data.endpoint = this.endpoint;
            }
            if (this.min_gpu != null) {
                data.min_gpu = this.min_gpu;
            }
            if (this.min_cpu != null) {
                data.min_cpu = this.min_cpu;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_endpoint && this.endpoint.length)
                writer.writeString(1, this.endpoint);
            if (this.has_min_gpu)
                writer.writeInt32(2, this.min_gpu);
            if (this.has_min_cpu)
                writer.writeInt32(3, this.min_cpu);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CapabilityFilters {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CapabilityFilters();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.endpoint = reader.readString();
                        break;
                    case 2:
                        message.min_gpu = reader.readInt32();
                        break;
                    case 3:
                        message.min_cpu = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CapabilityFilters {
            return CapabilityFilters.deserialize(bytes);
        }
    }
    export class ResourceRecruitment extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            recruitment_policy: ResourceRecruitment.RecruitmentPolicy;
            termination_policy: ResourceRecruitment.TerminationPolicy;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.recruitment_policy = data.recruitment_policy;
                this.termination_policy = data.termination_policy;
            }
        }
        get recruitment_policy() {
            return pb_1.Message.getField(this, 1) as ResourceRecruitment.RecruitmentPolicy;
        }
        set recruitment_policy(value: ResourceRecruitment.RecruitmentPolicy) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_recruitment_policy() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get termination_policy() {
            return pb_1.Message.getField(this, 2) as ResourceRecruitment.TerminationPolicy;
        }
        set termination_policy(value: ResourceRecruitment.TerminationPolicy) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_termination_policy() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            recruitment_policy?: ResourceRecruitment.RecruitmentPolicy;
            termination_policy?: ResourceRecruitment.TerminationPolicy;
        }): ResourceRecruitment {
            const message = new ResourceRecruitment({
                recruitment_policy: data.recruitment_policy,
                termination_policy: data.termination_policy
            });
            return message;
        }
        toObject() {
            const data: {
                recruitment_policy?: ResourceRecruitment.RecruitmentPolicy;
                termination_policy?: ResourceRecruitment.TerminationPolicy;
            } = {};
            if (this.recruitment_policy != null) {
                data.recruitment_policy = this.recruitment_policy;
            }
            if (this.termination_policy != null) {
                data.termination_policy = this.termination_policy;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_recruitment_policy)
                writer.writeEnum(1, this.recruitment_policy);
            if (this.has_termination_policy)
                writer.writeEnum(2, this.termination_policy);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResourceRecruitment {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResourceRecruitment();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.recruitment_policy = reader.readEnum();
                        break;
                    case 2:
                        message.termination_policy = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ResourceRecruitment {
            return ResourceRecruitment.deserialize(bytes);
        }
    }
    export namespace ResourceRecruitment {
        export enum RecruitmentPolicy {
            ALWAYS = 0,
            IF_NOT_PRESENT = 1,
            NEVER = 2,
            FAIL = 3
        }
        export enum TerminationPolicy {
            KEEP = 0,
            TERMINATE = 1
        }
    }
    export class ConsumeDataInputV1 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            query: dependency_1.domain_data.Query;
            keep_alive: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.query = data.query;
                this.keep_alive = data.keep_alive;
            }
        }
        get query() {
            return pb_1.Message.getWrapperField(this, dependency_1.domain_data.Query, 1) as dependency_1.domain_data.Query;
        }
        set query(value: dependency_1.domain_data.Query) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_query() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get keep_alive() {
            return pb_1.Message.getField(this, 2) as boolean;
        }
        set keep_alive(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_keep_alive() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            query?: ReturnType<typeof dependency_1.domain_data.Query.prototype.toObject>;
            keep_alive?: boolean;
        }): ConsumeDataInputV1 {
            const message = new ConsumeDataInputV1({
                query: dependency_1.domain_data.Query.fromObject(data.query),
                keep_alive: data.keep_alive
            });
            return message;
        }
        toObject() {
            const data: {
                query?: ReturnType<typeof dependency_1.domain_data.Query.prototype.toObject>;
                keep_alive?: boolean;
            } = {};
            if (this.query != null) {
                data.query = this.query.toObject();
            }
            if (this.keep_alive != null) {
                data.keep_alive = this.keep_alive;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_query)
                writer.writeMessage(1, this.query, () => this.query.serialize(writer));
            if (this.has_keep_alive)
                writer.writeBool(2, this.keep_alive);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConsumeDataInputV1 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConsumeDataInputV1();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.query, () => message.query = dependency_1.domain_data.Query.deserialize(reader));
                        break;
                    case 2:
                        message.keep_alive = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConsumeDataInputV1 {
            return ConsumeDataInputV1.deserialize(bytes);
        }
    }
    export class StoreDataOutputV1 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            ids: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.ids = data.ids;
            }
        }
        get ids() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set ids(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            ids: string[];
        }): StoreDataOutputV1 {
            const message = new StoreDataOutputV1({
                ids: data.ids
            });
            return message;
        }
        toObject() {
            const data: {
                ids: string[];
            } = {
                ids: this.ids
            };
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.ids.length)
                writer.writeRepeatedString(1, this.ids);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StoreDataOutputV1 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StoreDataOutputV1();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StoreDataOutputV1 {
            return StoreDataOutputV1.deserialize(bytes);
        }
    }
    export class LocalRefinementOutputV1 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            result_ids: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.result_ids = data.result_ids;
            }
        }
        get result_ids() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set result_ids(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            result_ids: string[];
        }): LocalRefinementOutputV1 {
            const message = new LocalRefinementOutputV1({
                result_ids: data.result_ids
            });
            return message;
        }
        toObject() {
            const data: {
                result_ids: string[];
            } = {
                result_ids: this.result_ids
            };
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.result_ids.length)
                writer.writeRepeatedString(1, this.result_ids);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocalRefinementOutputV1 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocalRefinementOutputV1();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocalRefinementOutputV1 {
            return LocalRefinementOutputV1.deserialize(bytes);
        }
    }
    export class Task extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name: string;
            receiver?: string;
            endpoint: string;
            access_token?: string;
            job_id: string;
            sender: string;
            status: Status;
            output?: Any;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.name = data.name;
                if ("receiver" in data && data.receiver != undefined) {
                    this.receiver = data.receiver;
                }
                this.endpoint = data.endpoint;
                if ("access_token" in data && data.access_token != undefined) {
                    this.access_token = data.access_token;
                }
                this.job_id = data.job_id;
                this.sender = data.sender;
                this.status = data.status;
                if ("output" in data && data.output != undefined) {
                    this.output = data.output;
                }
            }
        }
        get name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_name() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get receiver() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set receiver(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_receiver() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get endpoint() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set endpoint(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_endpoint() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get access_token() {
            return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
        }
        set access_token(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_access_token() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get job_id() {
            return pb_1.Message.getField(this, 6) as string;
        }
        set job_id(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get has_job_id() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get sender() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set sender(value: string) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_sender() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get status() {
            return pb_1.Message.getField(this, 9) as Status;
        }
        set status(value: Status) {
            pb_1.Message.setField(this, 9, value);
        }
        get has_status() {
            return pb_1.Message.getField(this, 9) != null;
        }
        get output() {
            return pb_1.Message.getWrapperField(this, Any, 10) as Any;
        }
        set output(value: Any) {
            pb_1.Message.setWrapperField(this, 10, value);
        }
        get has_output() {
            return pb_1.Message.getField(this, 10) != null;
        }
        static fromObject(data: {
            name?: string;
            receiver?: string;
            endpoint?: string;
            access_token?: string;
            job_id?: string;
            sender?: string;
            status?: Status;
            output?: ReturnType<typeof Any.prototype.toObject>;
        }): Task {
            const message = new Task({
                name: data.name,
                endpoint: data.endpoint,
                job_id: data.job_id,
                sender: data.sender,
                status: data.status
            });
            if (data.receiver != null) {
                message.receiver = data.receiver;
            }
            if (data.access_token != null) {
                message.access_token = data.access_token;
            }
            if (data.output != null) {
                message.output = Any.fromObject(data.output);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                receiver?: string;
                endpoint?: string;
                access_token?: string;
                job_id?: string;
                sender?: string;
                status?: Status;
                output?: ReturnType<typeof Any.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.receiver != null) {
                data.receiver = this.receiver;
            }
            if (this.endpoint != null) {
                data.endpoint = this.endpoint;
            }
            if (this.access_token != null) {
                data.access_token = this.access_token;
            }
            if (this.job_id != null) {
                data.job_id = this.job_id;
            }
            if (this.sender != null) {
                data.sender = this.sender;
            }
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.output != null) {
                data.output = this.output.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_name && this.name.length)
                writer.writeString(2, this.name);
            if (this.has_receiver && this.receiver.length)
                writer.writeString(3, this.receiver);
            if (this.has_endpoint && this.endpoint.length)
                writer.writeString(4, this.endpoint);
            if (this.has_access_token && this.access_token.length)
                writer.writeString(5, this.access_token);
            if (this.has_job_id && this.job_id.length)
                writer.writeString(6, this.job_id);
            if (this.has_sender && this.sender.length)
                writer.writeString(7, this.sender);
            if (this.has_status)
                writer.writeEnum(9, this.status);
            if (this.has_output)
                writer.writeMessage(10, this.output, () => this.output.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Task {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Task();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.receiver = reader.readString();
                        break;
                    case 4:
                        message.endpoint = reader.readString();
                        break;
                    case 5:
                        message.access_token = reader.readString();
                        break;
                    case 6:
                        message.job_id = reader.readString();
                        break;
                    case 7:
                        message.sender = reader.readString();
                        break;
                    case 9:
                        message.status = reader.readEnum();
                        break;
                    case 10:
                        reader.readMessage(message.output, () => message.output = Any.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Task {
            return Task.deserialize(bytes);
        }
    }
    export class LocalRefinementInputV1 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            query: dependency_1.domain_data.Query;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.query = data.query;
            }
        }
        get query() {
            return pb_1.Message.getWrapperField(this, dependency_1.domain_data.Query, 1) as dependency_1.domain_data.Query;
        }
        set query(value: dependency_1.domain_data.Query) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_query() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            query?: ReturnType<typeof dependency_1.domain_data.Query.prototype.toObject>;
        }): LocalRefinementInputV1 {
            const message = new LocalRefinementInputV1({
                query: dependency_1.domain_data.Query.fromObject(data.query)
            });
            return message;
        }
        toObject() {
            const data: {
                query?: ReturnType<typeof dependency_1.domain_data.Query.prototype.toObject>;
            } = {};
            if (this.query != null) {
                data.query = this.query.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_query)
                writer.writeMessage(1, this.query, () => this.query.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocalRefinementInputV1 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocalRefinementInputV1();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.query, () => message.query = dependency_1.domain_data.Query.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocalRefinementInputV1 {
            return LocalRefinementInputV1.deserialize(bytes);
        }
    }
    export class DomainClusterHandshake extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            access_token: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.access_token = data.access_token;
            }
        }
        get access_token() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set access_token(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_access_token() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            access_token?: string;
        }): DomainClusterHandshake {
            const message = new DomainClusterHandshake({
                access_token: data.access_token
            });
            return message;
        }
        toObject() {
            const data: {
                access_token?: string;
            } = {};
            if (this.access_token != null) {
                data.access_token = this.access_token;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_access_token && this.access_token.length)
                writer.writeString(1, this.access_token);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DomainClusterHandshake {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DomainClusterHandshake();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.access_token = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DomainClusterHandshake {
            return DomainClusterHandshake.deserialize(bytes);
        }
    }
    export class GlobalRefinementInputV1 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            local_refinement_results: LocalRefinementOutputV1[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.local_refinement_results = data.local_refinement_results;
            }
        }
        get local_refinement_results() {
            return pb_1.Message.getRepeatedWrapperField(this, LocalRefinementOutputV1, 1) as LocalRefinementOutputV1[];
        }
        set local_refinement_results(value: LocalRefinementOutputV1[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            local_refinement_results?: ReturnType<typeof LocalRefinementOutputV1.prototype.toObject>[];
        }): GlobalRefinementInputV1 {
            const message = new GlobalRefinementInputV1({
                local_refinement_results: data.local_refinement_results.map(item => LocalRefinementOutputV1.fromObject(item))
            });
            return message;
        }
        toObject() {
            const data: {
                local_refinement_results?: ReturnType<typeof LocalRefinementOutputV1.prototype.toObject>[];
            } = {};
            if (this.local_refinement_results != null) {
                data.local_refinement_results = this.local_refinement_results.map((item: LocalRefinementOutputV1) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.local_refinement_results.length)
                writer.writeRepeatedMessage(1, this.local_refinement_results, (item: LocalRefinementOutputV1) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GlobalRefinementInputV1 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GlobalRefinementInputV1();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.local_refinement_results, () => pb_1.Message.addToRepeatedWrapperField(message, 1, LocalRefinementOutputV1.deserialize(reader), LocalRefinementOutputV1));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GlobalRefinementInputV1 {
            return GlobalRefinementInputV1.deserialize(bytes);
        }
    }
    export class Error extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            message: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.message = data.message;
            }
        }
        get message() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_message() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            message?: string;
        }): Error {
            const message = new Error({
                message: data.message
            });
            return message;
        }
        toObject() {
            const data: {
                message?: string;
            } = {};
            if (this.message != null) {
                data.message = this.message;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_message && this.message.length)
                writer.writeString(1, this.message);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Error {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Error();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.message = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Error {
            return Error.deserialize(bytes);
        }
    }
    export class TaskHandler extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            task: Task;
            dependencies: Map<string, boolean>;
            job_id: string;
            err_msg: string;
            retries: number;
            updated_at: number;
            created_at: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                this.task = data.task;
                this.dependencies = data.dependencies;
                this.job_id = data.job_id;
                this.err_msg = data.err_msg;
                this.retries = data.retries;
                this.updated_at = data.updated_at;
                this.created_at = data.created_at;
            }
            if (!this.dependencies)
                this.dependencies = new Map();
        }
        get task() {
            return pb_1.Message.getWrapperField(this, Task, 1) as Task;
        }
        set task(value: Task) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_task() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get dependencies() {
            return pb_1.Message.getField(this, 2) as any as Map<string, boolean>;
        }
        set dependencies(value: Map<string, boolean>) {
            pb_1.Message.setField(this, 2, value as any);
        }
        get job_id() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set job_id(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_job_id() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get err_msg() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set err_msg(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_err_msg() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get retries() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set retries(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_retries() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get updated_at() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set updated_at(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get has_updated_at() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get created_at() {
            return pb_1.Message.getField(this, 7) as number;
        }
        set created_at(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_created_at() {
            return pb_1.Message.getField(this, 7) != null;
        }
        static fromObject(data: {
            task?: ReturnType<typeof Task.prototype.toObject>;
            dependencies?: {
                [key: string]: boolean;
            };
            job_id?: string;
            err_msg?: string;
            retries?: number;
            updated_at?: number;
            created_at?: number;
        }): TaskHandler {
            const message = new TaskHandler({
                task: Task.fromObject(data.task),
                dependencies: new Map(Object.entries(data.dependencies)),
                job_id: data.job_id,
                err_msg: data.err_msg,
                retries: data.retries,
                updated_at: data.updated_at,
                created_at: data.created_at
            });
            return message;
        }
        toObject() {
            const data: {
                task?: ReturnType<typeof Task.prototype.toObject>;
                dependencies?: {
                    [key: string]: boolean;
                };
                job_id?: string;
                err_msg?: string;
                retries?: number;
                updated_at?: number;
                created_at?: number;
            } = {};
            if (this.task != null) {
                data.task = this.task.toObject();
            }
            if (this.dependencies != null) {
                data.dependencies = (Object.fromEntries)(this.dependencies);
            }
            if (this.job_id != null) {
                data.job_id = this.job_id;
            }
            if (this.err_msg != null) {
                data.err_msg = this.err_msg;
            }
            if (this.retries != null) {
                data.retries = this.retries;
            }
            if (this.updated_at != null) {
                data.updated_at = this.updated_at;
            }
            if (this.created_at != null) {
                data.created_at = this.created_at;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_task)
                writer.writeMessage(1, this.task, () => this.task.serialize(writer));
            for (const [key, value] of this.dependencies) {
                writer.writeMessage(2, this.dependencies, () => {
                    writer.writeString(1, key);
                    writer.writeBool(2, value);
                });
            }
            if (this.has_job_id && this.job_id.length)
                writer.writeString(3, this.job_id);
            if (this.has_err_msg && this.err_msg.length)
                writer.writeString(4, this.err_msg);
            if (this.has_retries)
                writer.writeUint32(5, this.retries);
            if (this.has_updated_at)
                writer.writeUint64(6, this.updated_at);
            if (this.has_created_at)
                writer.writeUint64(7, this.created_at);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TaskHandler {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TaskHandler();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.task, () => message.task = Task.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.dependencies as any, reader, reader.readString, reader.readBool));
                        break;
                    case 3:
                        message.job_id = reader.readString();
                        break;
                    case 4:
                        message.err_msg = reader.readString();
                        break;
                    case 5:
                        message.retries = reader.readUint32();
                        break;
                    case 6:
                        message.updated_at = reader.readUint64();
                        break;
                    case 7:
                        message.created_at = reader.readUint64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TaskHandler {
            return TaskHandler.deserialize(bytes);
        }
    }
}
